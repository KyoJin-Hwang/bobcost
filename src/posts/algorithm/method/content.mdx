---
title: 'JS 코테에서 자주 사용되는 Method'
desc: 자바스크립트 Method를 먼저 알아야 효율적으로 문제를 풀 수 있기 때문에 Method를 정리하게 되었다.
createdAt: 2025-09-09 14:09
thumbnail: /posts/frontend/javascript/learnAlgorithm.png
group: JS
look: on
---

## 이 글을 정리하게 된 계기

Javascript로 코딩테스트를 준비하면서 가장 크게 느낀 어려움은 기초 지식 부족과 기억의 단절이었습니다.
- 배열, 문자열, 객체 관련 기본 메소드 활용법을 잘 기억하지 못해 매번 효율적인 코드 작성이 힘들었습니다.
- 피보나치 수열, 유클리드 호제법처럼 자주 등장하는 기본 알고리즘조차 구현할 때 잊어버리는 경우가 많았습니다.
- 반복적으로 등장하는 규칙과 패턴을 숙지하지 못하다 보니 문제 해결 속도도 늦어졌습니다.

이런 경험을 통해 단순히 문제 풀이 연습만 하는 것이 아니라, 자주 쓰이는 메소드와 알고리즘을 체계적으로 정리해두는 것이 필요하다고 느꼈습니다. 이 글의 목적은 기억을 강화하고, 실전 코딩테스트에서 바로 활용할 수 있는 유용한 팁과 메소드를 정리하는 데 있습니다.

## 글 구성

이번에는 알고리즘 문제 풀이 과정에서 가장 자주 활용되는 JavaScript 기본 Method를 정리합니다.
- Array, String, Object, Math 관련 메소드들의 기본 사용법
- 각 메소드를 실전에서 더 효율적으로 활용할 수 있는 팁과 패턴

이 글은 단순히 메소드를 나열하는 데 그치지 않고, 기초를 확실히 다지는 동시에 실전 코딩테스트 상황에서도 빠르게 떠올릴 수 있도록 정리하는 것을 목표로 합니다.


## String Method
### 💡 split

[MDN 참고링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/split)
> 📊 사용도: 상
> 👉 문자열 처리 문제에서 거의 필수적으로 쓰임

🔹 어떤 알고리즘 문제에 사용되는지
- 공백/쉼표/특수문자 기준으로 문자열을 나눠야 하는 문제
    - CSV, 공백 구분 단어, 로그 파일 처리 등
- 문자열을 배열로 변환해서 순회해야 하는 문제
    - 각 단어/문자 단위로 반복문, 조건문, 계산 수행
- 단어 개수 세기, 토큰화 기반 문제
    - 문장에서 단어 개수 세기, 특정 단어 존재 여부 확인

🔹 사용하는 이유
- 문자열을 배열 단위로 쪼개면 반복문, 정렬, 해시맵 등에 활용 가능
- 데이터 전처리가 필요한 경우에 필수


```javascript title='사용방법' showLineNumbers
// 1) 공백 기준으로 문자열 나누기
const str1 = "apple banana orange";
const arr1 = str1.split(" "); 
console.log(arr1); // ["apple", "banana", "orange"]

// 2) 쉼표 기준으로 문자열 나누기
const str2 = "red,green,blue";
const arr2 = str2.split(",");
console.log(arr2); // ["red","green","blue"]
```

---

### 💡 substring
> 📊 사용도: 중
> 👉 문자열의 일부를 잘라내는 데 자주 사용되며, 특히 부분 문자열 비교/검사 문제에서 유용

🔹 어떤 알고리즘 문제에 사용되는지
- 부분 문자열 추출이 필요한 문제
    - 특정 인덱스 구간의 문자열만 필요할 때
- 문자열 안에서 고정 길이 부분 문자열을 비교하거나 검사할 때
    - 문자열 안에서 고정 길이 부분 문자열을 비교하거나 검사할 때
- 접두사/접미사 관련 문제
    - 문자열이 특정 단어로 시작/끝나는지 검사할 때

🔹 사용 이유
- 원하는 시작 인덱스와 끝 인덱스를 지정해 문자열을 잘라낼 수 있음
- slice와 유사하지만, 음수 인덱스를 허용하지 않아 더 직관적일 때가 있음

```javascript title='사용방법' showLineNumbers
// 1) 시작~끝 인덱스까지 문자열 자르기
const str = "JavaScript";
console.log(str.substring(0, 4)); // "Java"

// 2) 한쪽만 넣으면 해당 인덱스부터 끝까지
console.log(str.substring(4)); // "Script"
```

---

### 💡 includes
> 📊 사용도: 상
> 👉 문자열이나 배열에서 특정 값의 포함 여부를 확인할 때 자주 사용됨

🔹 어떤 알고리즘 문제에 사용되는지  
- 문자열/배열 안에 특정 값이 존재하는지 확인해야 하는 문제  
- 조건 분기 문제에서 YES/NO 판단이 필요할 때  
- 중복 체크, 금지 단어 필터링 등  

🔹 사용 이유  
- `indexOf`보다 직관적이며 가독성이 좋음  
- 문자열/배열 포함 여부를 빠르게 확인 가능  

```javascript title='사용방법' showLineNumbers
// 문자열 포함 여부
const str = "javascript";
console.log(str.includes("java")); // true

// 배열 포함 여부
const arr = [1, 2, 3, 4];
console.log(arr.includes(3)); // true
```


---

### 💡 indexOf / lastIndexOf
> 📊 사용도: 상
> 👉 문자열이나 배열에서 특정 값의 위치를 찾을 때 자주 사용됨

🔹 어떤 알고리즘 문제에 사용되는지  
- 특정 문자의 첫 위치 또는 마지막 위치 확인  
- 문자열 검색 및 패턴 매칭  
- 배열 내 특정 요소의 인덱스 찾기  

🔹 사용 이유  
- 문자열/배열에서 값의 위치를 빠르게 확인 가능  
- 포함 여부 확인 + 위치 반환을 동시에 수행 가능  

```javascript title='사용방법' showLineNumbers
// indexOf: 처음 나오는 위치 반환, 없으면 -1
const str = "javascript";
console.log(str.indexOf("a")); // 1

// lastIndexOf: 마지막 나오는 위치 반환, 없으면 -1
console.log(str.lastIndexOf("a")); // 3

// 배열에서도 사용 가능
const arr = [1, 2, 3, 2];
console.log(arr.indexOf(2)); // 1
console.log(arr.lastIndexOf(2)); // 3
```

---

### 💡 replace / replaceAll
> 📊 사용도: 상
> 👉 문자열 내 특정 문자를 다른 문자로 바꾸거나 치환할 때 자주 사용됨

🔹 어떤 알고리즘 문제에 사용되는지  
- 문자열 내 특정 패턴을 다른 문자로 변환해야 하는 문제  
- 공백, 특수문자 제거 및 교체  
- 문자열 포맷 변환  

🔹 사용 이유  
- `replace`: 첫 번째 일치하는 문자/패턴만 치환  
- `replaceAll`: 모든 일치하는 문자/패턴 치환  
- 정규식 없이도 간단하게 치환 가능  

```javascript title='사용방법' showLineNumbers
const str = "hello world hello";

// replace: 첫 번째 일치만 변경
console.log(str.replace("hello", "hi")); // "hi world hello"

// replaceAll: 모든 일치 변경
console.log(str.replaceAll("hello", "hi")); // "hi world hi"

// 배열 내 문자열 치환
const arr = ["apple", "banana"];
console.log(arr.map(x => x.replace("a", "@"))); // ["@pple", "b@nana"]
```

---

### 💡 padStart / padEnd
> 📊 사용도: 중
> 👉 문자열의 길이를 맞추거나 특정 길이에 맞춰 앞/뒤를 채워야 할 때 자주 사용됨

🔹 어떤 알고리즘 문제에 사용되는지  
- 숫자, 문자열을 고정 길이로 맞춰야 하는 문제  
- 특정 포맷(날짜, 시간, 번호) 맞춤  
- 공백이나 특정 문자로 문자열 채우기  

🔹 사용 이유  
- 문자열 길이를 지정하고 남는 부분을 원하는 문자로 채울 수 있음  
- 포맷 통일 및 정렬에 용이  

```javascript title='사용방법' showLineNumbers
const str = "5";

// padStart: 앞쪽에 문자 추가
console.log(str.padStart(3, "0")); // "005"

// padEnd: 뒤쪽에 문자 추가
console.log(str.padEnd(3, "0"));   // "500"

// 길이가 이미 길면 변경 없음
console.log("12345".padStart(3, "0")); // "12345"
```

---
### 💡 toLowerCase / toUpperCase
> 📊 사용도: 상  
> 👉 문자열의 대소문자를 통일해야 할 때 자주 사용됨

🔹 어떤 알고리즘 문제에 사용되는지  
- 대소문자를 구분하지 않고 문자열 비교해야 할 때  
- 문자열 정렬, 검색, 필터링  
- 입력값 표준화  

🔹 사용 이유  
- 대소문자 구분 없이 비교 가능  
- 문자열을 일관된 형식으로 변환하여 오류 방지  

```javascript title='사용방법' showLineNumbers
const str = "JavaScript";

// toLowerCase: 소문자로 변환
console.log(str.toLowerCase()); // "javascript"

// toUpperCase: 대문자로 변환
console.log(str.toUpperCase()); // "JAVASCRIPT"

// 문자열 비교 시 활용
console.log(str.toLowerCase() === "javascript"); // true
```

---
### 💡 trim
> 📊 사용도: 상  
> 👉 문자열 양쪽 끝의 공백을 제거할 때 자주 사용됨

🔹 어떤 알고리즘 문제에 사용되는지  
- 입력값 전처리 문제 (공백 제거)  
- 문자열 비교, 정렬, 검색  
- 사용자 입력 데이터 처리  

🔹 사용 이유  
- 문자열 시작과 끝의 불필요한 공백 제거  
- 비교 및 처리 과정에서 오류 방지  

```javascript title='사용방법' showLineNumbers
const str = "   JavaScript   ";

// 양쪽 공백 제거
console.log(str.trim()); // "JavaScript"

// 문자열 비교 시 활용
console.log(str.trim() === "JavaScript"); // true

// 다른 문자열과 연결
console.log("Hello " + str.trim() + "!"); // "Hello JavaScript!"
```

---
### 💡 match
> 📊 사용도: 중  
> 👉 문자열에서 특정 패턴과 일치하는 부분을 찾을 때 사용됨

🔹 어떤 알고리즘 문제에 사용되는지  
- 특정 문자나 단어가 문자열에 몇 번 등장하는지 확인  
- 패턴 매칭, 조건 검사  
- 문자열 분석, 카운팅  

🔹 사용 이유  
- 정규식을 활용하면 반복되는 패턴을 한 번에 추출 가능  
- 배열로 결과 반환, 개수 확인에 용이  

```javascript title='사용방법' showLineNumbers
const str = "hello world hello";

// 단어 'hello' 모두 찾기
console.log(str.match(/hello/g)); // ["hello", "hello"]

// 특정 문자 찾기
console.log(str.match(/o/g)); // ["o", "o"]

// 일치하는 패턴이 없으면 null 반환
console.log(str.match(/bye/g)); // null
```

---

## Math, Number Method

### 💡 Math.max / Math.min
> 📊 사용도: 상  
> 👉 배열/값들 중 최댓값, 최솟값을 구할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 주어진 수 중 최대/최소 찾기  
- 배열에서 최댓값과 최솟값 비교  
- 조건에 따라 범위 확인  

🔹 사용 이유  
- 반복문 없이 빠르게 최댓값/최솟값 도출 가능  
- 스프레드 연산자와 같이 쓰면 배열에도 활용 가능  

```javascript title='사용방법' showLineNumbers
console.log(Math.max(3, 7, 2)); // 7
console.log(Math.min(3, 7, 2)); // 2

const arr = [3, 7, 2];
console.log(Math.max(...arr)); // 7
console.log(Math.min(...arr)); // 2
```

---

### 💡 Math.abs
> 📊 사용도: 상  
> 👉 어떤 수의 절댓값(부호 제거)을 구할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 두 값의 차이 계산 (거리, 오차, 차이 절댓값)  
- 좌표 거리 구하기 (맨해튼 거리 등)  
- 조건 비교 시 음수를 없애고 싶을 때  

🔹 사용 이유  
- `if` 조건문 없이 절댓값 바로 구할 수 있어 가독성, 효율성 ↑  
- 정렬, 거리 계산, 수학적 계산에 필수적  

```javascript title='사용방법' showLineNumbers
console.log(Math.abs(-10)); // 10
console.log(Math.abs(7));   // 7

// 두 수 차이 절댓값
const diff = Math.abs(5 - 12);
console.log(diff); // 7
```

---

### 💡 Math.floor / Math.ceil / Math.round / Math.trunc
> 📊 사용도: 상  
> 👉 소수점을 처리할 때 내림, 올림, 반올림, 정수화가 필요할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 점수/평균값 계산 후 반올림, 내림, 올림 처리  
- 몫 계산 (특히 정수 나눗셈)  
- 좌표/그리드 단위 계산 (격자 문제)  
- 소수점 이하 버리기  

🔹 사용 이유  
- 나눗셈 이후 정확한 정수값이 필요할 때 필수  
- 단순 `parseInt` 대신 의도에 맞는 메서드 사용 가능  

```javascript title='사용방법' showLineNumbers
console.log(Math.floor(3.9)); // 3  (내림)
console.log(Math.ceil(3.1));  // 4  (올림)
console.log(Math.round(3.5)); // 4  (반올림)
console.log(Math.trunc(3.9)); // 3  (소수점 절삭)
```

---

### 💡 Math.pow / Math.sqrt
> 📊 사용도: 상  
> 👉 제곱, 제곱근 계산이 필요한 경우에 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 제곱, 제곱근을 이용한 수학 계산  
- 거리 계산 (유클리드 거리)  
- 피타고라스 정리 문제  

🔹 사용 이유  
- `**` 연산자 대신 Math 메서드를 사용하면 가독성 ↑  
- 제곱근 계산 시 Math.sqrt로 간편하게 처리 가능  

```javascript title='사용방법' showLineNumbers
// 제곱
console.log(Math.pow(3, 2)); // 9
console.log(2 ** 3);         // 8 (같은 결과, ** 연산자)

// 제곱근
console.log(Math.sqrt(16));  // 4
console.log(Math.sqrt(2));   // 1.4142135623730951
```

---

### 💡 Math.random
> 📊 사용도: 상  
> 👉 난수 생성이 필요한 문제에서 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 랜덤 샘플링, 섞기 (shuffle)  
- 임의의 값 생성 (게임, 시뮬레이션, 테스트 케이스)  
- 확률 기반 알고리즘 구현  

🔹 사용 이유  
- 0 이상 1 미만의 난수를 쉽게 생성 가능  
- 범위 변환과 조합하면 다양한 난수 생성 가능  

```javascript title='사용방법' showLineNumbers
console.log(Math.random()); // 0 이상 1 미만 난수 예: 0.234567
console.log(Math.floor(Math.random() * 10)); // 0~9 사이 정수
console.log(Math.floor(Math.random() * 6) + 1); // 1~6 사이 정수 (주사위)
```

---

### 💡 Math.sign
> 📊 사용도: 중  
> 👉 수의 부호를 확인할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 수가 양수인지, 음수인지, 0인지 구분할 때  
- 절댓값이나 부호에 따라 다른 처리 수행  
- 배열, 좌표, 변화량 계산  

🔹 사용 이유  
- 부호 확인을 간단히 할 수 있어 조건문 단순화  
- 수 비교 및 방향 결정 문제에 유용  

```javascript title='사용방법' showLineNumbers
console.log(Math.sign(10));  // 1
console.log(Math.sign(-5));  // -1
console.log(Math.sign(0));   // 0

// 부호 활용 예시
const arr = [-3, 2, 0, -1];
const signs = arr.map(x => Math.sign(x));
console.log(signs); // [-1, 1, 0, -1]
```

---

### 💡 Number.prototype.toFixed
> 📊 사용도: 중  
> 👉 소수점 자리수를 고정하고 반올림할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 평균, 확률, 비율 계산 후 소수점 자리 고정  
- 소수점 비교, 출력 형식 맞추기  
- 통계, 금융 계산, 확률 기반 문제  

🔹 사용 이유  
- 소수점 처리를 간단하게 하고 계산 정확도 유지  
- 출력과 계산을 동시에 처리 가능  

```javascript title='사용방법' showLineNumbers
const num = 3.14159;
console.log(num.toFixed(2)); // "3.14"
console.log(num.toFixed(0)); // "3"

// 계산 후 숫자로 사용 가능
const avg = (10 + 15 + 20) / 3;
console.log(Number(avg.toFixed(1))); // 15.0
```

---

### 💡 Number.parseInt
> 📊 사용도: 상  
> 👉 문자열을 정수로 변환할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 문자열 입력값을 숫자로 변환해야 하는 문제  
- 계산, 인덱스, 자리수 계산, 토큰 처리 등  
- 문자열 내 숫자만 추출할 때  

🔹 사용 이유  
- parseInt로 문자열 내 숫자 추출 가능  
- NaN 방지, 계산 전 변환 필수  

```javascript title='사용방법' showLineNumbers
console.log(Number.parseInt("42px")); // 42
console.log(Number.parseInt("007"));  // 7
console.log(Number.parseInt("3.14")); // 3
```

---

### 💡 Number.isInteger
> 📊 사용도: 중  
> 👉 값이 정수인지 확인할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 수열, 나눗셈, 몫 계산  
- 조건문 분기, 정수 여부 확인  
- 부동소수점 계산 문제 처리  

🔹 사용 이유  
- 소수와 정수 구분 간편  
- 계산 정확도 및 조건 처리에 도움  

```javascript title='사용방법' showLineNumbers
console.log(Number.isInteger(5));    // true
console.log(Number.isInteger(3.14)); // false

// 배열 필터링 예시
const arr = [1, 2.5, 3, 4.1];
const integers = arr.filter(Number.isInteger);
console.log(integers); // [1, 3]
```

---

## Array Method

### 💡 Array.prototype.map
> 📊 사용도: 상  
> 👉 배열의 각 요소를 **변환(transform)** 할 때 사용  

🔹 어떤 알고리즘 문제에 사용되는지  
- 배열 내 값에 연산을 적용할 때 (예: 제곱, 변환 등)  
- 문자열/숫자 데이터 매핑  
- 좌표 변환, 데이터 포맷 변경  

🔹 사용 이유  
- 반복문 없이도 배열의 모든 요소에 쉽게 함수 적용 가능  
- 불변성 유지 (`map`은 원본 배열 변경 ❌ 새로운 배열 생성 ✅)  

```javascript title='사용방법' showLineNumbers
const arr = [1, 2, 3];
const squared = arr.map(x => x ** 2);
console.log(squared); // [1, 4, 9]
```

### 💡 Array.prototype.filter

> 📊 사용도: 상
> 👉 배열에서 조건을 만족하는 요소만 남길 때 사용

🔹 어떤 알고리즘 문제에 사용되는지
- 특정 기준으로 데이터 필터링
- 조건에 맞는 값만 추출 (짝수, 홀수, 음수, 양수 등)
- 유효한 데이터만 남기기

🔹 사용 이유
- 조건문과 push 없이 간결한 코드 가능
- 원본 배열 변경 ❌ ( Map 과 동일함)

```javascript title='사용방법' showLineNumbers
const numbers = [1, 2, 3, 4, 5];
const even = numbers.filter(n => n % 2 === 0);
console.log(even); // [2, 4]
```

--- 

### 💡 Array.prototype.reduce

> 📊 사용도: 상  
> 👉 배열의 모든 요소를 **누적(accumulate)** 하여 하나의 값으로 만들 때 사용

🔹 어떤 알고리즘 문제에 사용되는지
- 배열 요소 합계, 곱, 평균 계산
- 최대값/최소값 찾기
- 문자열 연결, 객체 집계 등

🔹 사용 이유
- 반복문 없이 누적 연산 가능
- 다양한 축약 작업에 활용
- 원본 배열 변경 ❌

```javascript title='사용방법' showLineNumbers
const numbers = [1, 2, 3, 4, 5];

// 합계 계산
const sum = numbers.reduce((acc, cur) => acc + cur, 0);
console.log(sum); // 15

// 최대값 찾기
const max = numbers.reduce((acc, cur) => (cur > acc ? cur : acc), numbers[0]);
console.log(max); // 5

// 문자열 연결
const words = ['hello', 'world'];
const sentence = words.reduce((acc, word) => acc + ' ' + word, '');
console.log(sentence); // " hello world"
```

---

### 💡 Array.prototype.forEach

> 📊 사용도: 상  
> 👉 배열을 순회하며 **부수 효과(side effect)** 수행할 때 사용

🔹 어떤 알고리즘 문제에 사용되는지
- 누적, 카운트, 출력, DOM 조작 등
- 데이터 전처리, 조건 체크

🔹 사용 이유
- 단순 순회 시 가독성 좋음
- 명령형 코드보다 선언적 표현 가능
- 원본 배열 변경 가능 ✅

```javascript title='사용방법' showLineNumbers
const letters = ['a', 'b', 'c'];

// 인덱스와 값 출력
letters.forEach((value, index) => console.log(index, value));
// 0 a
// 1 b
// 2 c

// 값 누적
let sum = 0;
const numbers = [1, 2, 3, 4, 5];
numbers.forEach(n => sum += n);
console.log(sum); // 15
```

---

### 💡 Array.prototype.find

> 📊 사용도: 중  
> 👉 조건을 만족하는 **첫 번째 요소**를 반환할 때 사용

🔹 어떤 알고리즘 문제에 사용되는지
- 특정 조건 만족 값 탐색
- 중복 데이터 중 첫 번째 일치 요소 찾기
- 특정 ID, 키 기반 객체 탐색

🔹 사용 이유
- 반복문 대신 간결하게 조건 탐색 가능
- 일치하는 요소 없으면 `undefined` 반환

```javascript title='사용방법' showLineNumbers
const users = [
  { id: 1, name: 'Tom' },
  { id: 2, name: 'Jane' },
  { id: 3, name: 'Bob' }
];

// id가 2인 객체 찾기
const user = users.find(u => u.id === 2);
console.log(user); // { id: 2, name: 'Jane' }

// 조건 없는 경우 undefined 반환
const notFound = users.find(u => u.id === 5);
console.log(notFound); // undefined

```

---

### 💡 Array.prototype.findIndex

> 📊 사용도: 중  
> 👉 조건을 만족하는 **첫 번째 요소의 인덱스**를 반환할 때 사용

🔹 어떤 알고리즘 문제에 사용되는지
- 특정 조건을 만족하는 요소 위치 찾기
- 배열 값 업데이트, 삭제 시 인덱스 필요
- 중복 데이터 중 첫 번째 일치 위치 탐색

🔹 사용 이유
- 반복문 없이 인덱스 탐색 가능
- 조건 만족 요소 없으면 `-1` 반환

```javascript title='사용방법' showLineNumbers
const users = [
  { id: 1, name: 'Tom' },
  { id: 2, name: 'Jane' },
  { id: 3, name: 'Bob' }
];

// id가 2인 객체의 인덱스 찾기
const index = users.findIndex(u => u.id === 2);
console.log(index); // 1

// 조건 만족 없으면 -1
const notFoundIndex = users.findIndex(u => u.id === 5);
console.log(notFoundIndex); // -1
```

---

### 💡 Array.prototype.some

> 📊 사용도: 중  
> 👉 배열 내 **하나라도 조건을 만족**하는지 확인

🔹 어떤 알고리즘 문제에 사용되는지
- 특정 값 존재 여부 확인
- 조건 만족 여부 체크 후 분기 처리
- 문제 조건 충족 여부 검증

🔹 사용 이유
- 반복문 + if 대신 간결하게 조건 체크 가능
- 불리언 결과 반환

```javascript title='사용방법' showLineNumbers
const numbers = [1, 2, 3, 4, 5];

// 배열에 짝수가 하나라도 있는지 확인
const hasEven = numbers.some(n => n % 2 === 0);
console.log(hasEven); // true

// 조건 만족 없으면 false
const hasGreaterThanTen = numbers.some(n => n > 10);
console.log(hasGreaterThanTen); // false
```

---

### 💡 Array.prototype.every

> 📊 사용도: 중  
> 👉 배열 내 **모든 요소가 조건을 만족**하는지 확인

🔹 어떤 알고리즘 문제에 사용되는지
- 배열 값 모두 양수인지, 특정 범위 내인지 확인
- 조건 검증 단계에서 유용
- 문제 조건 충족 여부 전체 체크

🔹 사용 이유
- 반복문 + if 없이 전체 조건 체크 가능
- 불리언 결과 반환

```javascript title='사용방법' showLineNumbers
const numbers = [2, 4, 6];

// 모든 요소가 짝수인지 확인
const allEven = numbers.every(n => n % 2 === 0);
console.log(allEven); // true

// 조건 만족하지 않으면 false
const numbers2 = [2, 3, 6];
const allEven2 = numbers2.every(n => n % 2 === 0);
console.log(allEven2); // false

```

---

### 💡 Array.prototype.includes

> 📊 사용도: 중  
> 👉 배열 내 **특정 값 존재 여부** 확인

🔹 어떤 알고리즘 문제에 사용되는지
- 중복 값 제거 시 체크
- 특정 값 포함 여부 확인 후 분기
- 배열 조건 검증

🔹 사용 이유
- indexOf보다 직관적
- 불리언 반환
- 간단한 조건 체크에 유용

```javascript title='사용방법' showLineNumbers
const numbers = [1, 2, 3];

// 값 존재 여부 확인
console.log(numbers.includes(2)); // true
console.log(numbers.includes(5)); // false

// 문자열 포함 확인
const fruits = ['apple', 'banana', 'orange'];
console.log(fruits.includes('banana')); // true
console.log(fruits.includes('grape'));  // false
```

---

### 💡 Array.prototype.flat

> 📊 사용도: 중  
> 👉 다차원 배열을 **지정 깊이(depth)까지 평탄화(flatten)** 할 때 사용

🔹 어떤 알고리즘 문제에 사용되는지
- 중첩 배열 1차원으로 변환
- 데이터를 단일 배열로 통합
- 다중 배열 요소 접근 및 연산

🔹 사용 이유
- 반복문 없이 배열 평탄화 가능
- map + concat보다 간결
- 깊이 지정 가능

```javascript title='사용방법' showLineNumbers
const nested = [1, [2, 3], [4, [5, 6]]];

// 기본: 1단계 평탄화
console.log(nested.flat()); // [1, 2, 3, 4, [5, 6]]

// 깊이 지정: 2단계까지 평탄화
console.log(nested.flat(2)); // [1, 2, 3, 4, 5, 6]

// 깊이 무한대(flatten all)
const deepNested = [1, [2, [3, [4]]]];
console.log(deepNested.flat(Infinity)); // [1, 2, 3, 4]
```

---

### 💡 Array.prototype.flatMap

> 📊 사용도: 중  
> 👉 배열을 변환하고 **1단계 평탄화(flat)** 동시에 수행

🔹 어떤 알고리즘 문제에 사용되는지
- 다중 배열 전처리 후 1차원 배열 생성
- 문자열 토큰화, 데이터 변환 + 평탄화
- map + flat(1) 결합 작업

🔹 사용 이유
- map과 flat(1) 결합으로 코드 간결
- 불변성 유지
- 1단계 배열 평탄화 필요 시 편리

```javascript title='사용방법' showLineNumbers
const phrases = ['hello world', 'foo bar'];

// 문자열을 공백 단위로 나누고 1차원 배열로 변환
const words = phrases.flatMap(str => str.split(' '));
console.log(words); // ['hello', 'world', 'foo', 'bar']

// 숫자 배열 변환 + 평탄화
const nested = [[1, 2], [3, 4]];
const doubled = nested.flatMap(arr => arr.map(x => x * 2));
console.log(doubled); // [2, 4, 6, 8]
```

--- 


### 💡 Array.prototype.concat

> 📊 사용도: 중  
> 👉 두 개 이상의 배열을 **합쳐 새로운 배열** 생성

🔹 어떤 알고리즘 문제에 사용되는지
- 배열 병합
- 중복 제거 전 배열 합치기
- 여러 데이터 소스 통합

🔹 사용 이유
- 원본 배열 변경 ❌
- 단순하고 직관적으로 배열 결합 가능

```javascript title='사용방법' showLineNumbers
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// 배열 합치기
const combined = arr1.concat(arr2);
console.log(combined); // [1, 2, 3, 4, 5, 6]

// 여러 배열 합치기
const arr3 = [7, 8];
const allCombined = arr1.concat(arr2, arr3);
console.log(allCombined); // [1, 2, 3, 4, 5, 6, 7, 8]

// 원본 배열은 변경되지 않음
console.log(arr1); // [1, 2, 3]
```

---

### 💡 Array.prototype.slice

> 📊 사용도: 중  
> 👉 배열의 **일부 요소를 잘라내어 새로운 배열** 생성

🔹 어떤 알고리즘 문제에 사용되는지
- 배열 일부 추출
- 구간 처리, 부분 배열 계산
- 원본 배열 유지하며 작업

🔹 사용 이유
- 원본 배열 변경 ❌
- 특정 구간 접근 시 간편

```javascript title='사용방법' showLineNumbers
const arr = [1, 2, 3, 4, 5];

// 인덱스 1~3 (끝 제외) 추출
const part = arr.slice(1, 4);
console.log(part); // [2, 3, 4]

// 시작 인덱스만 지정하면 끝까지 추출
console.log(arr.slice(2)); // [3, 4, 5]

// 음수 인덱스 사용 가능
console.log(arr.slice(-2)); // [4, 5]

// 원본 배열은 변경되지 않음
console.log(arr); // [1, 2, 3, 4, 5]
```

---

### 💡 Array.prototype.splice

> 📊 사용도: 중  
> 👉 배열의 **요소 제거, 추가, 교체** 가능 (원본 배열 변경)

🔹 어떤 알고리즘 문제에 사용되는지
- 배열 특정 위치 제거/추가
- 데이터 수정, 삽입
- 스택/큐 일부 조작

🔹 사용 이유
- 직접 배열 수정 가능 ✅
- 제거, 추가를 한 번에 처리 가능

```javascript title='사용방법' showLineNumbers
const arr = [1, 2, 3, 4, 5];

// 인덱스 1부터 2개 제거
const removed = arr.splice(1, 2);
console.log(removed); // [2, 3]
console.log(arr);     // [1, 4, 5]

// 인덱스 1 위치에 값 추가
arr.splice(1, 0, 20, 30);
console.log(arr); // [1, 20, 30, 4, 5]

// 제거 + 교체
arr.splice(2, 2, 99);
console.log(arr); // [1, 20, 99, 5]
```

---

### 💡 Array.prototype.push / pop / shift / unshift

> 📊 사용도: 상  
> 👉 배열의 **끝 또는 앞에 요소 추가/제거** 시 사용 (원본 배열 변경)

🔹 어떤 알고리즘 문제에 사용되는지
- 스택/큐 구현
- 배열 끝/앞 요소 삽입, 제거
- 데이터 처리 순서 관리

🔹 사용 이유
- 간단하게 배열 수정 가능 ✅
- 스택/큐 구조에서 직관적 사용 가능

```javascript title='사용방법' showLineNumbers
const arr = [1, 2, 3];

// push: 배열 끝에 요소 추가
arr.push(4);
console.log(arr); // [1, 2, 3, 4]

// pop: 배열 끝 요소 제거
const last = arr.pop();
console.log(last); // 4
console.log(arr);  // [1, 2, 3]

// unshift: 배열 앞에 요소 추가
arr.unshift(0);
console.log(arr); // [0, 1, 2, 3]

// shift: 배열 앞 요소 제거
const first = arr.shift();
console.log(first); // 0
console.log(arr);   // [1, 2, 3]
```

---

### 💡 Array.prototype.reverse

> 📊 사용도: 중  
> 👉 배열 요소의 **순서를 뒤집기** (원본 배열 변경)

🔹 어떤 알고리즘 문제에 사용되는지
- 배열 순서 반전
- 경로/순열 문제
- 스택/큐 구조 변환

🔹 사용 이유
- 반복문 없이 배열 순서 반전 가능
- 원본 배열 자체를 바꿀 수 있어 효율적

```javascript title='사용방법' showLineNumbers
const arr = [1, 2, 3, 4, 5];

arr.reverse();
console.log(arr); // [5, 4, 3, 2, 1]

// 문자열 배열도 가능
const letters = ['a', 'b', 'c'];
letters.reverse();
console.log(letters); // ['c', 'b', 'a']
```

---

### 💡 Array.prototype.sort

> 📊 사용도: 상  
> 👉 배열 요소를 **정렬** (원본 배열 변경, 기본은 문자열 기준)

🔹 어떤 알고리즘 문제에 사용되는지
- 숫자/문자 배열 정렬
- 조건 기반 정렬
- 최대/최소 값 탐색 전 처리

🔹 사용 이유
- 기본 문자열 정렬 외, 커스텀 비교 함수 가능
- 복잡한 정렬 문제도 단순화 가능

```javascript title='사용방법' showLineNumbers
const numbers = [10, 5, 20, 3];

// 숫자 오름차순 정렬
numbers.sort((a, b) => a - b);
console.log(numbers); // [3, 5, 10, 20]

// 숫자 내림차순 정렬
numbers.sort((a, b) => b - a);
console.log(numbers); // [20, 10, 5, 3]

// 문자열 정렬
const fruits = ['banana', 'apple', 'orange'];
fruits.sort();
console.log(fruits); // ['apple', 'banana', 'orange']
```

---

### 💡 Array.prototype.join

> 📊 사용도: 중  
> 👉 배열 요소를 **문자열로 합치기** (구분자 지정 가능)

🔹 어떤 알고리즘 문제에 사용되는지
- CSV, 출력 포맷 변환
- 문자열 재조합
- 배열 → 문자열 변환 후 조건 처리

🔹 사용 이유
- 간단하게 배열을 문자열로 변환 가능
- 구분자 지정으로 유연한 문자열 생성

```javascript title='사용방법' showLineNumbers
const arr = ['apple', 'banana', 'orange'];

// 기본 구분자: 쉼표
console.log(arr.join()); // "apple,banana,orange"

// 구분자 지정
console.log(arr.join(' - ')); // "apple - banana - orange"

// 숫자 배열도 가능
const numbers = [1, 2, 3];
console.log(numbers.join('')); // "123"

```

---

### 💡 Array.prototype.indexOf / lastIndexOf

> 📊 사용도: 중  
> 👉 배열 내 **특정 값의 인덱스 검색**  
> `indexOf`: 첫 번째 위치, `lastIndexOf`: 마지막 위치

🔹 어떤 알고리즘 문제에 사용되는지
- 중복 데이터 위치 확인
- 특정 값 존재 여부 체크
- 배열 값 업데이트/삭제 위치 탐색

🔹 사용 이유
- 반복문 없이 위치 확인 가능
- 없으면 -1 반환, 조건 처리 용이

```javascript title='사용방법' showLineNumbers
const arr = [1, 2, 3, 2, 4];

// 첫 번째 위치
console.log(arr.indexOf(2)); // 1

// 마지막 위치
console.log(arr.lastIndexOf(2)); // 3

// 없는 값
console.log(arr.indexOf(5)); // -1

```

## 💡 Object Method

<Callout type='info'>참고 자료</Callout>
1. https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects [MDN]
